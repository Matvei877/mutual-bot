import asyncio
import logging
import asyncpg
import os
from aiogram import Bot, Dispatcher, F, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton, 
    InlineKeyboardMarkup, InlineKeyboardButton,
    LabeledPrice, PreCheckoutQuery
)
from dotenv import load_dotenv

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø (–∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è) ---
TOKEN = os.getenv("BOT_TOKEN")
DATABASE_URL = os.getenv("DATABASE_URL")
ADMIN_IDS = [1945280694] # –£–∫–∞–∂–∏—Ç–µ –∑–¥–µ—Å—å —Å–≤–æ–π ID

# –ù–û–í–´–ï –ö–û–ù–°–¢–ê–ù–¢–´
CURRENCY_NAME = "FCOINS"
STARS_TO_FCOINS_RATE = 100  # 1 Star = 100 FCOINS
MIN_TASK_PRICE = 1.0        # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞ –∑–∞ –ø–æ–¥–ø–∏—Å—á–∏–∫–∞

if not TOKEN or not DATABASE_URL:
    raise ValueError("–ù–µ –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ .env —Ñ–∞–π–ª (BOT_TOKEN, DATABASE_URL)")

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

bot = Bot(token=TOKEN)
dp = Dispatcher()

db_pool = None

# --- –ë–ê–ó–ê –î–ê–ù–ù–´–• ---
async def init_db():
    global db_pool
    
    db_pool = await asyncpg.create_pool(dsn=DATABASE_URL, min_size=2, max_size=10)
    logger.info("–ü—É–ª –ë–î —Å–æ–∑–¥–∞–Ω")
    
    async with db_pool.acquire() as conn:
        # –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id BIGINT PRIMARY KEY,
                balance NUMERIC(10, 4) DEFAULT 0.0,
                earned_balance NUMERIC(10, 4) DEFAULT 0.0,
                created_at TIMESTAMP DEFAULT NOW()
            );
        ''')
        
        # –¢–∞–±–ª–∏—Ü–∞ –∏–Ω–≤–æ–π—Å–æ–≤ (Stars)
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS invoices (
                invoice_id TEXT PRIMARY KEY, 
                user_id BIGINT,
                amount NUMERIC(10, 4),
                payment_type TEXT DEFAULT 'stars',
                status TEXT DEFAULT 'active',
                created_at TIMESTAMP DEFAULT NOW()
            );
        ''')
        
        # –¢–∞–±–ª–∏—Ü–∞ –∑–∞–¥–∞–Ω–∏–π
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS tasks (
                id SERIAL PRIMARY KEY,
                owner_id BIGINT,
                channel_link TEXT,
                price_per_sub NUMERIC(10, 4), 
                count_needed INTEGER,
                count_done INTEGER DEFAULT 0,
                active BOOLEAN DEFAULT TRUE,
                created_at TIMESTAMP DEFAULT NOW()
            );
        ''')
        
        # –¢–∞–±–ª–∏—Ü–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS completed (
                user_id BIGINT,
                task_id INTEGER,
                completed_at TIMESTAMP DEFAULT NOW(),
                PRIMARY KEY (user_id, task_id)
            );
        ''')
        
        # –¢–∞–±–ª–∏—Ü–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS transactions (
                id SERIAL PRIMARY KEY,
                user_id BIGINT,
                amount NUMERIC(10, 4),
                type TEXT,
                description TEXT,
                created_at TIMESTAMP DEFAULT NOW()
            );
        ''')
        
        logger.info("‚úÖ –¢–∞–±–ª–∏—Ü—ã –ë–î —Å–æ–∑–¥–∞–Ω—ã/–ø—Ä–æ–≤–µ—Ä–µ–Ω—ã")

# --- DB HELPERS ---
async def db_get_user(user_id):
    try:
        async with db_pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO users (user_id) VALUES ($1) ON CONFLICT (user_id) DO NOTHING", 
                user_id
            )
            row = await conn.fetchrow("SELECT balance, earned_balance FROM users WHERE user_id = $1", user_id)
            if row:
                return float(row['balance']), float(row['earned_balance'])
            return 0.0, 0.0
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
        return 0.0, 0.0

async def db_update_balance(user_id, amount, tx_type=None, description=None, is_earned=False):
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞"""
    try:
        async with db_pool.acquire() as conn:
            async with conn.transaction():
                current = await conn.fetchrow(
                    "SELECT balance, earned_balance FROM users WHERE user_id = $1 FOR UPDATE", 
                    user_id
                )
                
                if current is None:
                    # –ï—Å–ª–∏ —é–∑–µ—Ä–∞ –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –Ω–∞ –ª–µ—Ç—É (—Ä–µ–¥–∫–∏–π –∫–µ–π—Å, –Ω–æ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏)
                    await conn.execute("INSERT INTO users (user_id) VALUES ($1)", user_id)
                    current = {'balance': 0.0, 'earned_balance': 0.0}
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ä–µ–¥—Å—Ç–≤ –ø—Ä–∏ —Å–ø–∏—Å–∞–Ω–∏–∏
                if amount < 0:
                    if is_earned:
                        if float(current['earned_balance']) < abs(amount):
                            raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–∞—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤")
                    else:
                        if float(current['balance']) < abs(amount):
                            raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤")
                
                # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ
                if is_earned:
                    await conn.execute(
                        "UPDATE users SET earned_balance = earned_balance + $1 WHERE user_id = $2", 
                        float(amount), user_id
                    )
                else:
                    await conn.execute(
                        "UPDATE users SET balance = balance + $1 WHERE user_id = $2", 
                        float(amount), user_id
                    )
                
                # –õ–æ–≥
                if tx_type:
                    await conn.execute(
                        "INSERT INTO transactions (user_id, amount, type, description) VALUES ($1, $2, $3, $4)",
                        user_id, float(amount), tx_type, description
                    )
                return True
                
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞ {user_id}: {e}")
        raise

async def db_add_task(owner_id, link, price, count):
    try:
        async with db_pool.acquire() as conn:
            task_id = await conn.fetchval(
                "INSERT INTO tasks (owner_id, channel_link, price_per_sub, count_needed) VALUES ($1, $2, $3, $4) RETURNING id",
                owner_id, link, float(price), int(count)
            )
            return task_id
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞–Ω–∏—è: {e}")
        raise

async def db_get_next_task(user_id):
    try:
        async with db_pool.acquire() as conn:
            return await conn.fetchrow('''
                SELECT id, channel_link, price_per_sub FROM tasks 
                WHERE active = TRUE AND count_done < count_needed 
                AND id NOT IN (SELECT task_id FROM completed WHERE user_id = $1)
                AND price_per_sub > 0
                ORDER BY price_per_sub DESC, created_at DESC
                LIMIT 1
            ''', user_id)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–¥–∞–Ω–∏—è –¥–ª—è {user_id}: {e}")
        return None

async def db_complete_task(user_id, task_id):
    try:
        async with db_pool.acquire() as conn:
            async with conn.transaction():
                exists = await conn.fetchval("SELECT 1 FROM completed WHERE user_id=$1 AND task_id=$2", user_id, task_id)
                if exists: return False
                
                task = await conn.fetchrow(
                    "SELECT count_done, count_needed, active, price_per_sub FROM tasks WHERE id = $1 FOR UPDATE",
                    task_id
                )
                if not task or not task['active'] or task['count_done'] >= task['count_needed']:
                    return False
                
                actual_price = float(task['price_per_sub'])
                
                await conn.execute("INSERT INTO completed (user_id, task_id) VALUES ($1, $2)", user_id, task_id)
                await conn.execute("UPDATE tasks SET count_done = count_done + 1 WHERE id = $1", task_id)
                
                # –ù–∞—á–∏—Å–ª—è–µ–º –Ω–∞ –∑–∞—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π –±–∞–ª–∞–Ω—Å
                await conn.execute("UPDATE users SET earned_balance = earned_balance + $1 WHERE user_id = $2", actual_price, user_id)
                
                await conn.execute(
                    "INSERT INTO transactions (user_id, amount, type, description) VALUES ($1, $2, $3, $4)",
                    user_id, actual_price, 'task_earn', f'–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è #{task_id}'
                )
                return True
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞–¥–∞–Ω–∏—è: {e}")
        return False

async def db_get_my_tasks(user_id):
    try:
        async with db_pool.acquire() as conn:
            return await conn.fetch('''
                SELECT id, channel_link, price_per_sub, count_needed, count_done, active 
                FROM tasks WHERE owner_id = $1 ORDER BY created_at DESC LIMIT 10
            ''', user_id)
    except Exception:
        return []

async def db_add_invoice(invoice_id, user_id, amount):
    try:
        async with db_pool.acquire() as conn:
            await conn.execute(
                "INSERT INTO invoices (invoice_id, user_id, amount, payment_type) VALUES ($1, $2, $3, 'stars')", 
                str(invoice_id), user_id, float(amount)
            )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–≤–æ–π—Å–∞: {e}")

# --- STATES ---
class AppStates(StatesGroup):
    waiting_ad_link = State()
    waiting_ad_count = State()
    waiting_ad_price = State()
    waiting_stars_amount = State()

# --- KEYBOARDS ---
main_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üí∞ –ó–∞—Ä–∞–±–æ—Ç–∞—Ç—å"), KeyboardButton(text="üì¢ –†–µ–∫–ª–∞–º–∏—Ä–æ–≤–∞—Ç—å")],
        [KeyboardButton(text="üë§ –ö–∞–±–∏–Ω–µ—Ç")]
    ],
    resize_keyboard=True,
    is_persistent=True,
    input_field_placeholder="–ú–µ–Ω—é"
)

def get_deposit_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚≠ê –ö—É–ø–∏—Ç—å FCOINS (Stars)", callback_data="topup_stars")]
    ])

def get_stars_amounts_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"10 ‚≠ê ({10 * STARS_TO_FCOINS_RATE} {CURRENCY_NAME})", callback_data="stars_10"),
         InlineKeyboardButton(text=f"50 ‚≠ê ({50 * STARS_TO_FCOINS_RATE} {CURRENCY_NAME})", callback_data="stars_50")],
        [InlineKeyboardButton(text=f"100 ‚≠ê ({100 * STARS_TO_FCOINS_RATE} {CURRENCY_NAME})", callback_data="stars_100"),
         InlineKeyboardButton(text=f"500 ‚≠ê ({500 * STARS_TO_FCOINS_RATE} {CURRENCY_NAME})", callback_data="stars_500")],
        [InlineKeyboardButton(text="‚úèÔ∏è –í–≤–µ—Å—Ç–∏ —Å–≤–æ—ë –∫–æ–ª-–≤–æ", callback_data="stars_custom")],
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="back_to_profile")]
    ])

def get_ads_menu_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞–Ω–∏–µ", callback_data="ad_new")],
        [InlineKeyboardButton(text="üìÇ –ú–æ–∏ –∑–∞–¥–∞–Ω–∏—è", callback_data="ad_list")]
    ])

def get_back_to_ads_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="ad_menu")]
    ])

def get_cancel_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
    ])

# --- HANDLERS ---

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    await db_get_user(message.from_user.id)
    await message.answer(
        f"üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</b>\n\n"
        f"–ë–∏—Ä–∂–∞ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –∑–∞ –≤–∞–ª—é—Ç—É <b>{CURRENCY_NAME}</b>.\n\n"
        f"üí∞ –ó–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ {CURRENCY_NAME} –∑–∞ –ø–æ–¥–ø–∏—Å–∫–∏\n"
        f"üì¢ –ü—Ä–æ–¥–≤–∏–≥–∞–π—Ç–µ —Å–≤–æ–∏ –∫–∞–Ω–∞–ª—ã –∑–∞ {CURRENCY_NAME}\n\n"
        f"1 Telegram Star ‚≠ê = {STARS_TO_FCOINS_RATE} {CURRENCY_NAME}",
        reply_markup=main_kb,
        parse_mode="HTML"
    )

@dp.message(F.text == "üë§ –ö–∞–±–∏–Ω–µ—Ç")
async def cmd_profile(message: types.Message):
    balance, earned_balance = await db_get_user(message.from_user.id)
    total = balance + earned_balance
    
    await message.answer(
        f"üë§ <b>–í–∞—à –∫–∞–±–∏–Ω–µ—Ç</b>\n\n"
        f"üÜî ID: <code>{message.from_user.id}</code>\n"
        f"üí≥ –ü–æ–ø–æ–ª–Ω–µ–Ω–æ: <b>{balance:.2f} {CURRENCY_NAME}</b>\n"
        f"‚öíÔ∏è –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ: <b>{earned_balance:.2f} {CURRENCY_NAME}</b>\n"
        f"üí∞ –í—Å–µ–≥–æ: <b>{total:.2f} {CURRENCY_NAME}</b>\n\n"
        f"–ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å –º–æ–∂–Ω–æ —á–µ—Ä–µ–∑ Telegram Stars.",
        reply_markup=get_deposit_kb(),
        parse_mode="HTML"
    )

@dp.callback_query(F.data == "back_to_profile")
async def back_to_profile_cb(callback: types.CallbackQuery):
    await cmd_profile(callback.message)
    await callback.answer()

# --- –ü–û–ü–û–õ–ù–ï–ù–ò–ï (STARS) ---

@dp.callback_query(F.data == "topup_stars")
async def topup_stars_menu(callback: types.CallbackQuery):
    await callback.message.edit_text(
        f"‚≠ê <b>–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ {CURRENCY_NAME}</b>\n\n"
        f"–ö—É—Ä—Å: 1 ‚≠ê = {STARS_TO_FCOINS_RATE} {CURRENCY_NAME}\n\n"
        f"–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤–µ–∑–¥ –¥–ª—è –æ–ø–ª–∞—Ç—ã:",
        reply_markup=get_stars_amounts_kb(),
        parse_mode="HTML"
    )
    await callback.answer()

@dp.callback_query(F.data.startswith("stars_") & (F.data != "stars_custom"))
async def process_stars_fixed(callback: types.CallbackQuery):
    stars_amount = int(callback.data.split("_")[1])
    await create_stars_invoice(callback.message, stars_amount, callback.from_user.id)
    await callback.answer()

@dp.callback_query(F.data == "stars_custom")
async def process_stars_custom(callback: types.CallbackQuery, state: FSMContext):
    await callback.message.answer(
        f"–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ Stars (–º–∏–Ω–∏–º—É–º 1):\n"
        f"–í—ã –ø–æ–ª—É—á–∏—Ç–µ –∫–æ–ª-–≤–æ Stars √ó {STARS_TO_FCOINS_RATE} {CURRENCY_NAME}",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(AppStates.waiting_stars_amount)
    await callback.answer()

@dp.message(AppStates.waiting_stars_amount)
async def process_stars_custom_amount(message: types.Message, state: FSMContext):
    try:
        stars_amount = int(message.text)
        if stars_amount < 1:
            await message.answer("‚ùå –ú–∏–Ω–∏–º—É–º 1 Star")
            return
        if stars_amount > 10000:
            await message.answer("‚ùå –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞ —Ä–∞–∑")
            return
        
        await create_stars_invoice(message, stars_amount, message.from_user.id)
        await state.clear()
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ")

async def create_stars_invoice(message: types.Message, stars_amount: int, user_id: int):
    try:
        fcoins_amount = stars_amount * STARS_TO_FCOINS_RATE
        payload = f"stars_{user_id}_{message.message_id}_{stars_amount}"
        
        prices = [LabeledPrice(label=f"{fcoins_amount} {CURRENCY_NAME}", amount=stars_amount)]
        
        await bot.send_invoice(
            chat_id=user_id,
            title=f"–ü–æ–∫—É–ø–∫–∞ {CURRENCY_NAME}",
            description=f"–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–∞ {fcoins_amount} {CURRENCY_NAME}",
            payload=payload,
            currency="XTR",
            prices=prices,
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=f"–û–ø–ª–∞—Ç–∏—Ç—å {stars_amount} ‚≠ê", pay=True)]])
        )
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º "–ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ" –∏–Ω–≤–æ–π—Å
        await db_add_invoice(payload, user_id, fcoins_amount)
        
    except Exception as e:
        logger.error(f"Error invoice: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—á–µ—Ç–∞")

@dp.pre_checkout_query()
async def process_pre_checkout(pre_checkout_query: PreCheckoutQuery):
    await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)

@dp.message(F.successful_payment)
async def process_successful_payment(message: types.Message):
    try:
        # –í–∞–∂–Ω–æ: successful_payment.total_amount –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—É–º–º—É –≤ "–∫–æ–ø–µ–π–∫–∞—Ö" –∏–ª–∏ "–∑–≤–µ–∑–¥–∞—Ö"
        # –î–ª—è XTR (Stars) total_amount = –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∑–≤–µ–∑–¥
        stars_paid = message.successful_payment.total_amount
        fcoins_amount = stars_paid * STARS_TO_FCOINS_RATE
        user_id = message.from_user.id
        
        await db_update_balance(
            user_id, 
            fcoins_amount,
            tx_type='deposit_stars',
            description=f'–ü–æ–∫—É–ø–∫–∞ –∑–∞ {stars_paid} Stars',
            is_earned=False
        )
        
        await message.answer(
            f"‚úÖ <b>–û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!</b>\n\n"
            f"‚≠ê –°–ø–∏—Å–∞–Ω–æ: {stars_paid} Stars\n"
            f"üí∞ –ó–∞—á–∏—Å–ª–µ–Ω–æ: <b>{fcoins_amount} {CURRENCY_NAME}</b>",
            parse_mode="HTML"
        )
    except Exception as e:
        logger.error(f"Payment error: {e}")

# --- ADMIN COMMAND ---
@dp.message(Command("give"))
async def cmd_admin_give(message: types.Message):
    if message.from_user.id not in ADMIN_IDS: return
    try:
        _, user_id_str, amount_str = message.text.split()
        user_id = int(user_id_str)
        amount = float(amount_str)
        
        await db_update_balance(user_id, amount, tx_type='admin_bonus', description='üéÅ –ë–æ–Ω—É—Å –∞–¥–º–∏–Ω–∞', is_earned=False)
        await message.answer(f"‚úÖ –í—ã–¥–∞–Ω–æ {amount} {CURRENCY_NAME} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        await bot.send_message(user_id, f"üéÅ –ê–¥–º–∏–Ω –Ω–∞—á–∏—Å–ª–∏–ª –≤–∞–º <b>{amount} {CURRENCY_NAME}</b>!", parse_mode="HTML")
    except Exception as e:
        await message.answer(f"Error: {e}")

# --- –†–ï–ö–õ–ê–ú–ê ---

@dp.message(F.text == "üì¢ –†–µ–∫–ª–∞–º–∏—Ä–æ–≤–∞—Ç—å")
async def cmd_advertise_menu(message: types.Message):
    await message.answer("üì¢ <b>–†–∞–∑–¥–µ–ª —Ä–µ–∫–ª–∞–º—ã</b>", reply_markup=get_ads_menu_kb(), parse_mode="HTML")

@dp.callback_query(F.data == "ad_new")
async def cb_new_ad(callback: types.CallbackQuery, state: FSMContext):
    await callback.message.answer(
        "üìù <b>–ù–æ–≤–æ–µ –∑–∞–¥–∞–Ω–∏–µ</b>\n\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –∫–∞–Ω–∞–ª (@channel –∏–ª–∏ https://t.me/channel)\n"
        "‚ö†Ô∏è –ë–æ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º –∫–∞–Ω–∞–ª–∞!",
        reply_markup=get_cancel_kb(),
        parse_mode="HTML"
    )
    await state.set_state(AppStates.waiting_ad_link)
    await callback.answer()

@dp.callback_query(F.data == "ad_list")
async def cb_my_ads(callback: types.CallbackQuery):
    tasks = await db_get_my_tasks(callback.from_user.id)
    if not tasks:
        await callback.message.edit_text("üì≠ –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π –Ω–µ—Ç", reply_markup=get_back_to_ads_kb())
        return
    text = "üìÇ <b>–í–∞—à–∏ –∑–∞–¥–∞–Ω–∏—è:</b>\n\n"
    for t in tasks:
        status = "üü¢" if t['active'] and t['count_done'] < t['count_needed'] else "üî¥"
        text += f"{status} <b>#{t['id']}</b> {t['channel_link']}\nüí∞ {t['price_per_sub']} {CURRENCY_NAME} | üìä {t['count_done']}/{t['count_needed']}\n\n"
    await callback.message.edit_text(text, parse_mode="HTML", reply_markup=get_back_to_ads_kb())

@dp.callback_query(F.data == "ad_menu")
async def cb_back_to_ads_menu(callback: types.CallbackQuery):
    await callback.message.edit_text("üì¢ <b>–†–∞–∑–¥–µ–ª —Ä–µ–∫–ª–∞–º—ã</b>", reply_markup=get_ads_menu_kb(), parse_mode="HTML")

@dp.message(AppStates.waiting_ad_link)
async def process_ad_link(message: types.Message, state: FSMContext):
    link = message.text.strip()
    if not link.startswith('@') and 'https://t.me/' not in link:
        await message.answer("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞")
        return
    await state.update_data(link=link)
    await message.answer("üìä –°–∫–æ–ª—å–∫–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –Ω—É–∂–Ω–æ?", reply_markup=get_cancel_kb())
    await state.set_state(AppStates.waiting_ad_count)

@dp.message(AppStates.waiting_ad_count)
async def process_ad_count(message: types.Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ")
        return
    count = int(message.text)
    if count <= 0: return
    await state.update_data(count=count)
    await message.answer(
        f"üí∞ –¶–µ–Ω–∞ –∑–∞ 1 –ø–æ–¥–ø–∏—Å—á–∏–∫–∞ –≤ {CURRENCY_NAME}?\n"
        f"–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ: {MIN_TASK_PRICE} {CURRENCY_NAME}",
        reply_markup=get_cancel_kb()
    )
    await state.set_state(AppStates.waiting_ad_price)

@dp.message(AppStates.waiting_ad_price)
async def process_ad_price(message: types.Message, state: FSMContext):
    try:
        price = float(message.text)
        if price < MIN_TASK_PRICE:
            await message.answer(f"‚ùå –ú–∏–Ω–∏–º—É–º {MIN_TASK_PRICE} {CURRENCY_NAME}")
            return
        
        data = await state.get_data()
        cost = price * data['count']
        balance, earned = await db_get_user(message.from_user.id)
        total = balance + earned
        
        if total < cost:
            await message.answer(f"‚ùå –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç —Å—Ä–µ–¥—Å—Ç–≤. –ù—É–∂–Ω–æ: {cost} {CURRENCY_NAME}, —É –≤–∞—Å: {total} {CURRENCY_NAME}")
            await state.clear()
            return
        
        # –õ–æ–≥–∏–∫–∞ —Å–ø–∏—Å–∞–Ω–∏—è: —Å–Ω–∞—á–∞–ª–∞ balance, –ø–æ—Ç–æ–º earned_balance
        if balance >= cost:
            await db_update_balance(message.from_user.id, -cost, 'task_create', f'–ó–∞–¥–∞–Ω–∏–µ {data["count"]} –ø–æ–¥–ø.', False)
        else:
            if balance > 0:
                await db_update_balance(message.from_user.id, -balance, 'task_create', '–ß–∞—Å—Ç—å –æ–ø–ª–∞—Ç—ã 1', False)
            remaining = cost - balance
            await db_update_balance(message.from_user.id, -remaining, 'task_create', '–ß–∞—Å—Ç—å –æ–ø–ª–∞—Ç—ã 2', True)
        
        task_id = await db_add_task(message.from_user.id, data['link'], price, data['count'])
        await message.answer(f"‚úÖ –ó–∞–¥–∞–Ω–∏–µ #{task_id} —Å–æ–∑–¥–∞–Ω–æ!\n–°–ø–∏—Å–∞–Ω–æ: {cost} {CURRENCY_NAME}")
        await state.clear()
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ")

# --- –ó–ê–†–ê–ë–û–¢–û–ö ---

@dp.message(F.text == "üí∞ –ó–∞—Ä–∞–±–æ—Ç–∞—Ç—å")
async def cmd_earn(message: types.Message):
    task = await db_get_next_task(message.from_user.id)
    if not task:
        await message.answer("üòî –ó–∞–¥–∞–Ω–∏–π –ø–æ–∫–∞ –Ω–µ—Ç")
        return
    
    link = task['channel_link']
    if not link.startswith('http'): link = f"https://t.me/{link.replace('@', '')}"
    
    price = float(task['price_per_sub'])
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîó –ü–µ—Ä–µ–π—Ç–∏", url=link)],
        [InlineKeyboardButton(text=f"‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å (+{price} {CURRENCY_NAME})", callback_data=f"check_{task['id']}")]
    ])
    
    await message.answer(
        f"üí∞ <b>–ó–∞–¥–∞–Ω–∏–µ</b>\n–ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ {task['channel_link']}\n–ù–∞–≥—Ä–∞–¥–∞: <b>{price} {CURRENCY_NAME}</b>",
        reply_markup=kb, parse_mode="HTML"
    )

@dp.callback_query(F.data.startswith("check_"))
async def process_check_task(callback: types.CallbackQuery):
    task_id = int(callback.data.split("_")[1])
    
    # –ü–æ–ª—É—á–∞–µ–º –ª–∏–Ω–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
    async with db_pool.acquire() as conn:
        task_data = await conn.fetchrow("SELECT channel_link, price_per_sub FROM tasks WHERE id=$1", task_id)
    
    if not task_data:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ –∑–∞–¥–∞–Ω–∏—è")
        return

    channel_username = task_data['channel_link'].replace('@', '').replace('https://t.me/', '').strip('/')
    
    try:
        member = await bot.get_chat_member(chat_id=f"@{channel_username}", user_id=callback.from_user.id)
        if member.status in ['member', 'administrator', 'creator']:
            if await db_complete_task(callback.from_user.id, task_id):
                await callback.message.delete()
                _, earned = await db_get_user(callback.from_user.id)
                await callback.message.answer(
                    f"‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ! +{task_data['price_per_sub']} {CURRENCY_NAME}\n–ë–∞–ª–∞–Ω—Å: {earned} {CURRENCY_NAME}",
                    reply_markup=main_kb
                )
            else:
                await callback.answer("‚ùå –£–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –∏–ª–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ", show_alert=True)
        else:
            await callback.answer("‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã!", show_alert=True)
    except Exception:
        await callback.answer("‚ùå –ë–æ—Ç –Ω–µ –∞–¥–º–∏–Ω –≤ –∫–∞–Ω–∞–ª–µ –∏–ª–∏ –æ—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏", show_alert=True)

@dp.callback_query(F.data == "cancel")
async def cancel_handler(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ", reply_markup=main_kb)
    await callback.answer()

async def main():
    await init_db()
    await bot.delete_webhook(drop_pending_updates=True)
    try:
        logger.info("Bot started")
        await dp.start_polling(bot)
    finally:
        await bot.session.close()
        if db_pool: await db_pool.close()

if __name__ == "__main__":
    asyncio.run(main())